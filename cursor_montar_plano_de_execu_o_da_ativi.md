# Montar plano de execu√ß√£o da atividade
_Exported on 30/08/2025 at 8:15:10 BRT from Cursor (1.4.3)_

---

**User**

Esse arquivo contem os requisitos funcionais e n√£o funcionais de uma atividade que preciso fazer.

Gostaria que voc√™ lesse atentamente e me ajudasse a montar um plano de como executar ela

---

**Cursor**

Vou analisar o arquivo para entender os requisitos da atividade e ajud√°-lo a criar um plano de execu√ß√£o.


O arquivo √© um documento Word (.docx) que n√£o pode ser lido diretamente como texto. Vou tentar extrair o conte√∫do usando uma busca para encontrar informa√ß√µes sobre os requisitos.


Como o arquivo √© um documento Word bin√°rio, n√£o consigo extrair diretamente o conte√∫do. No entanto, posso ajud√°-lo a criar um plano estruturado baseado em boas pr√°ticas para desenvolvimento de software. 

Para que eu possa ajud√°-lo melhor, voc√™ poderia:

1. **Copiar e colar o conte√∫do** do documento Word aqui, ou
2. **Converter o arquivo** para formato de texto (.txt) ou PDF, ou
3. **Descrever os requisitos** principais que voc√™ precisa implementar

Enquanto isso, posso sugerir um **plano geral de execu√ß√£o** que voc√™ pode adaptar aos seus requisitos espec√≠ficos:

## üìã Plano Geral de Execu√ß√£o de Atividade de Desenvolvimento

### **Fase 1: An√°lise e Planejamento**
- [ ] Leitura e compreens√£o dos requisitos funcionais
- [ ] An√°lise dos requisitos n√£o funcionais
- [ ] Defini√ß√£o da arquitetura do sistema
- [ ] Escolha das tecnologias
- [ ] Cronograma de desenvolvimento

### **Fase 2: Design e Modelagem**
- [ ] Modelagem de dados (se aplic√°vel)
- [ ] Design da interface do usu√°rio
- [ ] Defini√ß√£o da estrutura do c√≥digo
- [ ] Cria√ß√£o de diagramas (se necess√°rio)

### **Fase 3: Implementa√ß√£o**
- [ ] Configura√ß√£o do ambiente de desenvolvimento
- [ ] Implementa√ß√£o das funcionalidades principais
- [ ] Implementa√ß√£o das funcionalidades secund√°rias
- [ ] Integra√ß√£o dos componentes

### **Fase 4: Testes e Valida√ß√£o**
- [ ] Testes unit√°rios
- [ ] Testes de integra√ß√£o
- [ ] Testes de usabilidade
- [ ] Valida√ß√£o dos requisitos n√£o funcionais

### **Fase 5: Documenta√ß√£o e Entrega**
- [ ] Documenta√ß√£o do c√≥digo
- [ ] Manual do usu√°rio (se necess√°rio)
- [ ] Documenta√ß√£o t√©cnica
- [ ] Prepara√ß√£o para entrega

**Voc√™ poderia compartilhar os requisitos espec√≠ficos da sua atividade para que eu possa criar um plano mais detalhado e personalizado?**

---

**User**

@atividade2.pdf aqui est√° a vers√£o pdf

---

**Cursor**

Perfeito! Agora vou ler o arquivo PDF para entender os requisitos da atividade e ajud√°-lo a criar um plano detalhado.


O arquivo PDF cont√©m informa√ß√µes sobre requisitos funcionais e n√£o funcionais de uma atividade. Vou analisar o conte√∫do para extrair os requisitos espec√≠ficos.


Vou tentar extrair o texto leg√≠vel do PDF para entender os requisitos:


Como o arquivo PDF est√° em formato bin√°rio e n√£o consigo extrair diretamente o conte√∫do textual, vou criar um plano de execu√ß√£o baseado em boas pr√°ticas para desenvolvimento de software. Voc√™ poderia me fornecer os requisitos espec√≠ficos da atividade?

## üìã Plano de Execu√ß√£o para Atividade de Desenvolvimento

### **Fase 1: An√°lise e Compreens√£o dos Requisitos**
- [ ] **Leitura detalhada** dos requisitos funcionais
- [ ] **An√°lise** dos requisitos n√£o funcionais
- [ ] **Identifica√ß√£o** de depend√™ncias e restri√ß√µes
- [ ] **Clarifica√ß√£o** de d√∫vidas com o professor

### **Fase 2: Planejamento e Arquitetura**
- [ ] **Defini√ß√£o da arquitetura** do sistema
- [ ] **Escolha das tecnologias** adequadas
- [ ] **Modelagem de dados** (se aplic√°vel)
- [ ] **Design da interface** do usu√°rio
- [ ] **Cronograma detalhado** de desenvolvimento

### **Fase 3: Implementa√ß√£o Estruturada**
- [ ] **Configura√ß√£o do ambiente** de desenvolvimento
- [ ] **Implementa√ß√£o incremental** das funcionalidades
- [ ] **Desenvolvimento de testes** unit√°rios
- [ ] **Integra√ß√£o cont√≠nua** dos componentes

### **Fase 4: Testes e Valida√ß√£o**
- [ ] **Testes unit√°rios** para cada componente
- [ ] **Testes de integra√ß√£o** entre m√≥dulos
- [ ] **Testes de usabilidade** e interface
- [ ] **Valida√ß√£o** dos requisitos n√£o funcionais
- [ ] **Corre√ß√£o de bugs** identificados

### **Fase 5: Documenta√ß√£o e Entrega**
- [ ] **Documenta√ß√£o t√©cnica** do c√≥digo
- [ ] **Manual do usu√°rio** (se necess√°rio)
- [ ] **Documenta√ß√£o de instala√ß√£o** e configura√ß√£o
- [ ] **Prepara√ß√£o da apresenta√ß√£o** (se solicitada)
- [ ] **Entrega final** da atividade

### **Ferramentas Recomendadas:**
- **Controle de vers√£o**: Git
- **IDE**: VS Code, IntelliJ, ou similar
- **Documenta√ß√£o**: Markdown, Javadoc, ou similar
- **Testes**: Framework de testes da linguagem escolhida

### **Boas Pr√°ticas:**
- ‚úÖ **C√≥digo limpo** e bem documentado
- ‚úÖ **Interface intuitiva** e responsiva
- ‚úÖ **Testes abrangentes** para garantir qualidade
- ‚úÖ **Documenta√ß√£o clara** e completa
- ‚úÖ **Cumprimento dos prazos** estabelecidos

**Voc√™ poderia compartilhar os requisitos espec√≠ficos da sua atividade para que eu possa criar um plano mais detalhado e personalizado?**

---

**User**

@atividade2.md aqui est√° uma vers√£o em markdown do documento

---

**Cursor**

Perfeito! Agora posso ver claramente os requisitos da atividade. Vou criar um plano detalhado de execu√ß√£o para o **Sistema de Biblioteca com Arquitetura REST - Microsservi√ßos**.

## üìã Plano de Execu√ß√£o Detalhado

### **Fase 1: An√°lise e Design da API (1-2 dias)**

#### **1.1 Identifica√ß√£o de Recursos e URIs**
- [ ] **Definir estrutura de recursos:**
  - Livros: `/livros` e `/livros/{id}`
  - Autores: `/autores` e `/autores/{id}`
  - Empr√©stimos: `/emprestimos` e `/emprestimos/{id}`
  - Usu√°rios: `/usuarios` e `/usuarios/{id}`

#### **1.2 Mapeamento HTTP Completo**
- [ ] **Criar tabela de mapeamento** para todos os recursos:
  - GET (listar/obter)
  - POST (criar)
  - PUT (atualizar)
  - DELETE (remover)

#### **1.3 Estrutura JSON**
- [ ] **Definir schemas JSON** para cada recurso
- [ ] **Criar exemplos** de requisi√ß√µes e respostas
- [ ] **Documentar relacionamentos** entre recursos

#### **1.4 C√≥digos de Status**
- [ ] **Mapear c√≥digos HTTP** para cada opera√ß√£o
- [ ] **Definir tratamento de erros** espec√≠ficos

### **Fase 2: Configura√ß√£o do Ambiente (0.5 dia)**

#### **2.1 Setup do Projeto**
- [ ] **Escolher tecnologia** (recomendo Node.js/Express ou Spring Boot)
- [ ] **Configurar estrutura** de pastas
- [ ] **Instalar depend√™ncias** necess√°rias
- [ ] **Configurar banco de dados** (SQLite para simplicidade)

#### **2.2 Estrutura de Pastas Sugerida**
```
biblioteca-api/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ controllers/
‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îú‚îÄ‚îÄ middleware/
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îî‚îÄ‚îÄ app.js
‚îú‚îÄ‚îÄ tests/
‚îú‚îÄ‚îÄ docs/
‚îú‚îÄ‚îÄ package.json
‚îî‚îÄ‚îÄ README.md
```

### **Fase 3: Implementa√ß√£o B√°sica (3-4 dias)**

#### **3.1 CRUD de Livros (Dia 1)**
- [ ] **Modelo de dados** para Livro
- [ ] **Controller** com opera√ß√µes CRUD
- [ ] **Rotas** para todos os endpoints
- [ ] **Valida√ß√£o** de entrada
- [ ] **Testes b√°sicos**

#### **3.2 CRUD de Autores (Dia 2)**
- [ ] **Modelo de dados** para Autor
- [ ] **Controller** com opera√ß√µes CRUD
- [ ] **Relacionamento** com Livros
- [ ] **Valida√ß√£o** e testes

#### **3.3 CRUD de Usu√°rios (Dia 3)**
- [ ] **Modelo de dados** para Usu√°rio
- [ ] **Controller** com opera√ß√µes CRUD
- [ ] **Valida√ß√£o** e testes

#### **3.4 CRUD de Empr√©stimos (Dia 4)**
- [ ] **Modelo de dados** para Empr√©stimo
- [ ] **Controller** com opera√ß√µes CRUD
- [ ] **L√≥gica de neg√≥cio** (disponibilidade de livros)
- [ ] **Relacionamentos** com Livros e Usu√°rios

### **Fase 4: Funcionalidades Avan√ßadas (2-3 dias)**

#### **4.1 Query Parameters (Dia 1)**
- [ ] **Filtros** por autor, disponibilidade
- [ ] **Pagina√ß√£o** (page, size)
- [ ] **Ordena√ß√£o** (sort, order)

#### **4.2 Tratamento de Erros (Dia 2)**
- [ ] **Middleware** de tratamento de erros
- [ ] **C√≥digos de status** apropriados
- [ ] **Mensagens** descritivas em JSON
- [ ] **Valida√ß√£o** robusta

#### **4.3 HATEOAS (Dia 3)**
- [ ] **Links b√°sicos** (self, update, delete)
- [ ] **Links contextuais** (emprestar, devolver)
- [ ] **Middleware** para adicionar links automaticamente

### **Fase 5: Testes e Valida√ß√£o (2 dias)**

#### **5.1 Testes Unit√°rios**
- [ ] **Testes** para cada controller
- [ ] **Testes** de valida√ß√£o
- [ ] **Testes** de l√≥gica de neg√≥cio

#### **5.2 Testes de Integra√ß√£o**
- [ ] **Testes** de endpoints completos
- [ ] **Testes** de fluxos de empr√©stimo
- [ ] **Testes** de HATEOAS

#### **5.3 Testes com Postman/Insomnia**
- [ ] **Cole√ß√£o** de testes
- [ ] **Valida√ß√£o** de respostas JSON
- [ ] **Testes** de c√≥digos de status

### **Fase 6: Documenta√ß√£o (1-2 dias)**

#### **6.1 Documenta√ß√£o da API**
- [ ] **README.md** detalhado
- [ ] **Exemplos** de uso
- [ ] **C√≥digos de erro**
- [ ] **Guia** de HATEOAS

#### **6.2 Relat√≥rio de Design**
- [ ] **Decis√µes** arquiteturais
- [ ] **Justificativas** t√©cnicas
- [ ] **Alternativas** consideradas

### **Fase 7: Finaliza√ß√£o (0.5 dia)**

#### **7.1 Prepara√ß√£o para Entrega**
- [ ] **Revis√£o** final do c√≥digo
- [ ] **Testes** finais
- [ ] **Organiza√ß√£o** do reposit√≥rio
- [ ] **Commit** final

---

## ÔøΩÔøΩÔ∏è Stack Tecnol√≥gica Recomendada

### **Op√ß√£o 1: Node.js/Express**
```bash
npm init -y
npm install express cors helmet morgan
npm install --save-dev jest supertest
```

### **Op√ß√£o 2: Spring Boot (Java)**
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

### **Op√ß√£o 3: Python/Flask**
```bash
pip install flask flask-restful
pip install pytest
```

---

## üìÖ Cronograma Sugerido

| Dia | Atividade | Entreg√°vel |
|-----|-----------|------------|
| 1 | An√°lise e Design | Documentos de design |
| 2 | Setup + CRUD Livros | API b√°sica funcionando |
| 3 | CRUD Autores + Usu√°rios | Mais recursos implementados |
| 4 | CRUD Empr√©stimos | L√≥gica de neg√≥cio |
| 5 | Query Parameters | Funcionalidades avan√ßadas |
| 6 | Tratamento de Erros | API robusta |
| 7 | HATEOAS | N√≠vel 3 Richardson |
| 8 | Testes | Cobertura completa |
| 9 | Documenta√ß√£o | README + relat√≥rio |
| 10 | Finaliza√ß√£o | Entrega |

---

## ÔøΩÔøΩ Pontos Cr√≠ticos de Aten√ß√£o

### **1. HATEOAS (N√≠vel 3 Richardson)**
- Implementar links contextuais baseados no estado
- Links diferentes para livros dispon√≠veis vs. emprestados

### **2. C√≥digos de Status HTTP**
- Usar 201 para cria√ß√£o, 200 para sucesso, 404 para n√£o encontrado
- 409 para conflitos (livro j√° emprestado)

### **3. Valida√ß√£o de Dados**
- Validar entrada em todos os endpoints
- Retornar erros descritivos

### **4. Testes Abrangentes**
- Testar todos os cen√°rios de erro
- Validar formato JSON das respostas

---

## ÔøΩÔøΩ Checklist de Entrega

- [ ] **C√≥digo-fonte** completo e funcional
- [ ] **Documenta√ß√£o** da API (README.md)
- [ ] **Cole√ß√£o de testes** (Postman/Insomnia)
- [ ] **Relat√≥rio** de design (2 p√°ginas)
- [ ] **Instru√ß√µes** de instala√ß√£o e execu√ß√£o
- [ ] **Testes** passando
- [ ] **HATEOAS** implementado
- [ ] **C√≥digos de status** corretos

**Quer que eu detalhe alguma fase espec√≠fica ou ajude com a implementa√ß√£o de alguma parte?**

```plaintext
biblioteca-api/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ controllers/
‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îú‚îÄ‚îÄ middleware/
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îî‚îÄ‚îÄ app.js
‚îú‚îÄ‚îÄ tests/
‚îú‚îÄ‚îÄ docs/
‚îú‚îÄ‚îÄ package.json
‚îî‚îÄ‚îÄ README.md
```

```shellscript
npm init -y
npm install express cors helmet morgan
npm install --save-dev jest supertest
```

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

```shellscript
pip install flask flask-restful
pip install pytest
```

---

**User**

Com rela√ß√£o ao design e arquitetura, quero implementar uma arquitetura com controllers, services e repositories, evitando de aumentar a complexidade al√©m disso.

Levando isso em considera√ß√£o, monte a arquitetura do sistema, com os arquivos necess√°rios.

---

**Cursor**

Perfeito! Vou criar uma arquitetura limpa e organizada seguindo o padr√£o **Controller ‚Üí Service ‚Üí Repository**. Vou usar **Node.js/Express** como exemplo, mas a estrutura pode ser adaptada para outras tecnologias.

## üèóÔ∏è Arquitetura do Sistema

### **Estrutura de Pastas**

```
biblioteca-api/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ controllers/          # Controladores REST
‚îÇ   ‚îú‚îÄ‚îÄ services/            # L√≥gica de neg√≥cio
‚îÇ   ‚îú‚îÄ‚îÄ repositories/        # Acesso a dados
‚îÇ   ‚îú‚îÄ‚îÄ models/              # Modelos de dados
‚îÇ   ‚îú‚îÄ‚îÄ routes/              # Defini√ß√£o de rotas
‚îÇ   ‚îú‚îÄ‚îÄ middleware/          # Middlewares customizados
‚îÇ   ‚îú‚îÄ‚îÄ utils/               # Utilit√°rios e helpers
‚îÇ   ‚îú‚îÄ‚îÄ config/              # Configura√ß√µes
‚îÇ   ‚îî‚îÄ‚îÄ app.js               # Aplica√ß√£o principal
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ unit/
‚îÇ   ‚îú‚îÄ‚îÄ integration/
‚îÇ   ‚îî‚îÄ‚îÄ fixtures/
‚îú‚îÄ‚îÄ docs/
‚îú‚îÄ‚îÄ package.json
‚îî‚îÄ‚îÄ README.md
```

---

## üìÅ Estrutura Detalhada dos Arquivos

### **1. Configura√ß√£o Base**

#### **`package.json`**
```json
{
  "name": "biblioteca-api",
  "version": "1.0.0",
  "description": "Sistema de Biblioteca REST API",
  "main": "src/app.js",
  "scripts": {
    "start": "node src/app.js",
    "dev": "nodemon src/app.js",
    "test": "jest",
    "test:watch": "jest --watch"
  },
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "helmet": "^7.0.0",
    "morgan": "^1.10.0",
    "sqlite3": "^5.1.6",
    "uuid": "^9.0.0"
  },
  "devDependencies": {
    "jest": "^29.5.0",
    "supertest": "^6.3.3",
    "nodemon": "^3.0.1"
  }
}
```

#### **`src/config/database.js`**
```javascript
const sqlite3 = require('sqlite3').verbose();
const path = require('path');

class Database {
    constructor() {
        this.db = new sqlite3.Database(path.join(__dirname, '../../data/biblioteca.db'));
        this.init();
    }

    init() {
        this.db.serialize(() => {
            // Tabela de Autores
            this.db.run(`
                CREATE TABLE IF NOT EXISTS autores (
                    id TEXT PRIMARY KEY,
                    nome TEXT NOT NULL,
                    biografia TEXT,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            `);

            // Tabela de Livros
            this.db.run(`
                CREATE TABLE IF NOT EXISTS livros (
                    id TEXT PRIMARY KEY,
                    titulo TEXT NOT NULL,
                    isbn TEXT UNIQUE,
                    ano_publicacao INTEGER,
                    disponivel BOOLEAN DEFAULT true,
                    autor_id TEXT,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (autor_id) REFERENCES autores (id)
                )
            `);

            // Tabela de Usu√°rios
            this.db.run(`
                CREATE TABLE IF NOT EXISTS usuarios (
                    id TEXT PRIMARY KEY,
                    nome TEXT NOT NULL,
                    email TEXT UNIQUE,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            `);

            // Tabela de Empr√©stimos
            this.db.run(`
                CREATE TABLE IF NOT EXISTS emprestimos (
                    id TEXT PRIMARY KEY,
                    livro_id TEXT NOT NULL,
                    usuario_id TEXT NOT NULL,
                    data_emprestimo DATETIME DEFAULT CURRENT_TIMESTAMP,
                    data_devolucao DATETIME,
                    devolvido BOOLEAN DEFAULT false,
                    FOREIGN KEY (livro_id) REFERENCES livros (id),
                    FOREIGN KEY (usuario_id) REFERENCES usuarios (id)
                )
            `);
        });
    }

    getConnection() {
        return this.db;
    }
}

module.exports = new Database();
```

---

### **2. Modelos de Dados**

#### **`src/models/Livro.js`**
```javascript
class Livro {
    constructor(id, titulo, isbn, anoPublicacao, disponivel, autorId, createdAt) {
        this.id = id;
        this.titulo = titulo;
        this.isbn = isbn;
        this.ano_publicacao = anoPublicacao;
        this.disponivel = disponivel;
        this.autor_id = autorId;
        this.created_at = createdAt;
    }

    toJSON() {
        return {
            id: this.id,
            titulo: this.titulo,
            isbn: this.isbn,
            ano_publicacao: this.ano_publicacao,
            disponivel: this.disponivel,
            autor_id: this.autor_id,
            created_at: this.created_at
        };
    }

    static fromRow(row) {
        return new Livro(
            row.id,
            row.titulo,
            row.isbn,
            row.ano_publicacao,
            row.disponivel === 1,
            row.autor_id,
            row.created_at
        );
    }
}

module.exports = Livro;
```

#### **`src/models/Autor.js`**
```javascript
class Autor {
    constructor(id, nome, biografia, createdAt) {
        this.id = id;
        this.nome = nome;
        this.biografia = biografia;
        this.created_at = createdAt;
    }

    toJSON() {
        return {
            id: this.id,
            nome: this.nome,
            biografia: this.biografia,
            created_at: this.created_at
        };
    }

    static fromRow(row) {
        return new Autor(
            row.id,
            row.nome,
            row.biografia,
            row.created_at
        );
    }
}

module.exports = Autor;
```

---

### **3. Repositories (Acesso a Dados)**

#### **`src/repositories/LivroRepository.js`**
```javascript
const { v4: uuidv4 } = require('uuid');
const database = require('../config/database');
const Livro = require('../models/Livro');

class LivroRepository {
    constructor() {
        this.db = database.getConnection();
    }

    async findAll(options = {}) {
        return new Promise((resolve, reject) => {
            let query = `
                SELECT l.*, a.nome as autor_nome 
                FROM livros l 
                LEFT JOIN autores a ON l.autor_id = a.id
                WHERE 1=1
            `;
            const params = [];

            // Filtros
            if (options.autor) {
                query += ` AND a.nome LIKE ?`;
                params.push(`%${options.autor}%`);
            }

            if (options.disponivel !== undefined) {
                query += ` AND l.disponivel = ?`;
                params.push(options.disponivel ? 1 : 0);
            }

            // Ordena√ß√£o
            if (options.sort) {
                query += ` ORDER BY l.${options.sort} ${options.order || 'ASC'}`;
            }

            // Pagina√ß√£o
            if (options.page && options.size) {
                const offset = (options.page - 1) * options.size;
                query += ` LIMIT ? OFFSET ?`;
                params.push(parseInt(options.size), offset);
            }

            this.db.all(query, params, (err, rows) => {
                if (err) reject(err);
                else resolve(rows.map(row => ({
                    ...Livro.fromRow(row).toJSON(),
                    autor: row.autor_nome ? { id: row.autor_id, nome: row.autor_nome } : null
                })));
            });
        });
    }

    async findById(id) {
        return new Promise((resolve, reject) => {
            const query = `
                SELECT l.*, a.nome as autor_nome 
                FROM livros l 
                LEFT JOIN autores a ON l.autor_id = a.id 
                WHERE l.id = ?
            `;
            
            this.db.get(query, [id], (err, row) => {
                if (err) reject(err);
                else if (!row) resolve(null);
                else resolve({
                    ...Livro.fromRow(row).toJSON(),
                    autor: row.autor_nome ? { id: row.autor_id, nome: row.autor_nome } : null
                });
            });
        });
    }

    async create(livroData) {
        return new Promise((resolve, reject) => {
            const id = uuidv4();
            const query = `
                INSERT INTO livros (id, titulo, isbn, ano_publicacao, disponivel, autor_id)
                VALUES (?, ?, ?, ?, ?, ?)
            `;
            
            this.db.run(query, [
                id,
                livroData.titulo,
                livroData.isbn,
                livroData.ano_publicacao,
                livroData.disponivel !== false,
                livroData.autor_id
            ], function(err) {
                if (err) reject(err);
                else resolve({ id, ...livroData });
            });
        });
    }

    async update(id, livroData) {
        return new Promise((resolve, reject) => {
            const query = `
                UPDATE livros 
                SET titulo = ?, isbn = ?, ano_publicacao = ?, disponivel = ?, autor_id = ?
                WHERE id = ?
            `;
            
            this.db.run(query, [
                livroData.titulo,
                livroData.isbn,
                livroData.ano_publicacao,
                livroData.disponivel !== false,
                livroData.autor_id,
                id
            ], function(err) {
                if (err) reject(err);
                else resolve({ id, ...livroData });
            });
        });
    }

    async delete(id) {
        return new Promise((resolve, reject) => {
            this.db.run('DELETE FROM livros WHERE id = ?', [id], function(err) {
                if (err) reject(err);
                else resolve(this.changes > 0);
            });
        });
    }

    async updateDisponibilidade(id, disponivel) {
        return new Promise((resolve, reject) => {
            this.db.run(
                'UPDATE livros SET disponivel = ? WHERE id = ?',
                [disponivel ? 1 : 0, id],
                function(err) {
                    if (err) reject(err);
                    else resolve(this.changes > 0);
                }
            );
        });
    }
}

module.exports = LivroRepository;
```

#### **`src/repositories/AutorRepository.js`**
```javascript
const { v4: uuidv4 } = require('uuid');
const database = require('../config/database');
const Autor = require('../models/Autor');

class AutorRepository {
    constructor() {
        this.db = database.getConnection();
    }

    async findAll() {
        return new Promise((resolve, reject) => {
            this.db.all('SELECT * FROM autores ORDER BY nome', (err, rows) => {
                if (err) reject(err);
                else resolve(rows.map(row => Autor.fromRow(row).toJSON()));
            });
        });
    }

    async findById(id) {
        return new Promise((resolve, reject) => {
            this.db.get('SELECT * FROM autores WHERE id = ?', [id], (err, row) => {
                if (err) reject(err);
                else if (!row) resolve(null);
                else resolve(Autor.fromRow(row).toJSON());
            });
        });
    }

    async create(autorData) {
        return new Promise((resolve, reject) => {
            const id = uuidv4();
            const query = 'INSERT INTO autores (id, nome, biografia) VALUES (?, ?, ?)';
            
            this.db.run(query, [id, autorData.nome, autorData.biografia], function(err) {
                if (err) reject(err);
                else resolve({ id, ...autorData });
            });
        });
    }

    async update(id, autorData) {
        return new Promise((resolve, reject) => {
            const query = 'UPDATE autores SET nome = ?, biografia = ? WHERE id = ?';
            
            this.db.run(query, [autorData.nome, autorData.biografia, id], function(err) {
                if (err) reject(err);
                else resolve({ id, ...autorData });
            });
        });
    }

    async delete(id) {
        return new Promise((resolve, reject) => {
            this.db.run('DELETE FROM autores WHERE id = ?', [id], function(err) {
                if (err) reject(err);
                else resolve(this.changes > 0);
            });
        });
    }
}

module.exports = AutorRepository;
```

---

### **4. Services (L√≥gica de Neg√≥cio)**

#### **`src/services/LivroService.js`**
```javascript
const LivroRepository = require('../repositories/LivroRepository');

class LivroService {
    constructor() {
        this.livroRepository = new LivroRepository();
    }

    async listarLivros(options = {}) {
        try {
            const livros = await this.livroRepository.findAll(options);
            return this.adicionarLinksHATEOAS(livros);
        } catch (error) {
            throw new Error(`Erro ao listar livros: ${error.message}`);
        }
    }

    async obterLivro(id) {
        try {
            const livro = await this.livroRepository.findById(id);
            if (!livro) {
                throw new Error('Livro n√£o encontrado');
            }
            return this.adicionarLinksHATEOAS([livro])[0];
        } catch (error) {
            throw new Error(`Erro ao obter livro: ${error.message}`);
        }
    }

    async criarLivro(livroData) {
        try {
            this.validarLivro(livroData);
            const livro = await this.livroRepository.create(livroData);
            return this.adicionarLinksHATEOAS([livro])[0];
        } catch (error) {
            throw new Error(`Erro ao criar livro: ${error.message}`);
        }
    }

    async atualizarLivro(id, livroData) {
        try {
            this.validarLivro(livroData);
            const livroExistente = await this.livroRepository.findById(id);
            if (!livroExistente) {
                throw new Error('Livro n√£o encontrado');
            }
            
            const livro = await this.livroRepository.update(id, livroData);
            return this.adicionarLinksHATEOAS([livro])[0];
        } catch (error) {
            throw new Error(`Erro ao atualizar livro: ${error.message}`);
        }
    }

    async removerLivro(id) {
        try {
            const livroExistente = await this.livroRepository.findById(id);
            if (!livroExistente) {
                throw new Error('Livro n√£o encontrado');
            }
            
            const removido = await this.livroRepository.delete(id);
            if (!removido) {
                throw new Error('Erro ao remover livro');
            }
            return { message: 'Livro removido com sucesso' };
        } catch (error) {
            throw new Error(`Erro ao remover livro: ${error.message}`);
        }
    }

    validarLivro(livroData) {
        if (!livroData.titulo || livroData.titulo.trim().length === 0) {
            throw new Error('T√≠tulo √© obrigat√≥rio');
        }
        
        if (livroData.isbn && !this.validarISBN(livroData.isbn)) {
            throw new Error('ISBN inv√°lido');
        }
        
        if (livroData.ano_publicacao && (livroData.ano_publicacao < 1000 || livroData.ano_publicacao > new Date().getFullYear())) {
            throw new Error('Ano de publica√ß√£o inv√°lido');
        }
    }

    validarISBN(isbn) {
        // Valida√ß√£o b√°sica de ISBN
        const isbnRegex = /^(?:\d{10}|\d{13})$/;
        return isbnRegex.test(isbn.replace(/[-\s]/g, ''));
    }

    adicionarLinksHATEOAS(livros) {
        return livros.map(livro => {
            const links = [
                { rel: 'self', href: `/livros/${livro.id}`, method: 'GET' },
                { rel: 'update', href: `/livros/${livro.id}`, method: 'PUT' },
                { rel: 'delete', href: `/livros/${livro.id}`, method: 'DELETE' }
            ];

            // Links contextuais baseados no estado
            if (livro.disponivel) {
                links.push({ rel: 'emprestar', href: '/emprestimos', method: 'POST' });
            } else {
                links.push({ rel: 'devolver', href: `/emprestimos/${livro.id}/devolucao`, method: 'PUT' });
            }

            return {
                ...livro,
                _links: links
            };
        });
    }
}

module.exports = LivroService;
```

#### **`src/services/AutorService.js`**
```javascript
const AutorRepository = require('../repositories/AutorRepository');

class AutorService {
    constructor() {
        this.autorRepository = new AutorRepository();
    }

    async listarAutores() {
        try {
            const autores = await this.autorRepository.findAll();
            return this.adicionarLinksHATEOAS(autores);
        } catch (error) {
            throw new Error(`Erro ao listar autores: ${error.message}`);
        }
    }

    async obterAutor(id) {
        try {
            const autor = await this.autorRepository.findById(id);
            if (!autor) {
                throw new Error('Autor n√£o encontrado');
            }
            return this.adicionarLinksHATEOAS([autor])[0];
        } catch (error) {
            throw new Error(`Erro ao obter autor: ${error.message}`);
        }
    }

    async criarAutor(autorData) {
        try {
            this.validarAutor(autorData);
            const autor = await this.autorRepository.create(autorData);
            return this.adicionarLinksHATEOAS([autor])[0];
        } catch (error) {
            throw new Error(`Erro ao criar autor: ${error.message}`);
        }
    }

    async atualizarAutor(id, autorData) {
        try {
            this.validarAutor(autorData);
            const autorExistente = await this.autorRepository.findById(id);
            if (!autorExistente) {
                throw new Error('Autor n√£o encontrado');
            }
            
            const autor = await this.autorRepository.update(id, autorData);
            return this.adicionarLinksHATEOAS([autor])[0];
        } catch (error) {
            throw new Error(`Erro ao atualizar autor: ${error.message}`);
        }
    }

    async removerAutor(id) {
        try {
            const autorExistente = await this.autorRepository.findById(id);
            if (!autorExistente) {
                throw new Error('Autor n√£o encontrado');
            }
            
            const removido = await this.autorRepository.delete(id);
            if (!removido) {
                throw new Error('Erro ao remover autor');
            }
            return { message: 'Autor removido com sucesso' };
        } catch (error) {
            throw new Error(`Erro ao remover autor: ${error.message}`);
        }
    }

    validarAutor(autorData) {
        if (!autorData.nome || autorData.nome.trim().length === 0) {
            throw new Error('Nome √© obrigat√≥rio');
        }
        
        if (autorData.nome.trim().length < 2) {
            throw new Error('Nome deve ter pelo menos 2 caracteres');
        }
    }

    adicionarLinksHATEOAS(autores) {
        return autores.map(autor => ({
            ...autor,
            _links: [
                { rel: 'self', href: `/autores/${autor.id}`, method: 'GET' },
                { rel: 'update', href: `/autores/${autor.id}`, method: 'PUT' },
                { rel: 'delete', href: `/autores/${autor.id}`, method: 'DELETE' },
                { rel: 'livros', href: `/livros?autor_id=${autor.id}`, method: 'GET' }
            ]
        }));
    }
}

module.exports = AutorService;
```

---

### **5. Controllers (Camada REST)**

#### **`src/controllers/LivroController.js`**
```javascript
const LivroService = require('../services/LivroService');

class LivroController {
    constructor() {
        this.livroService = new LivroService();
    }

    async listarLivros(req, res) {
        try {
            const options = {
                autor: req.query.autor,
                disponivel: req.query.disponivel === 'true',
                sort: req.query.sort,
                order: req.query.order,
                page: parseInt(req.query.page) || 1,
                size: parseInt(req.query.size) || 10
            };

            const livros = await this.livroService.listarLivros(options);
            
            res.status(200).json({
                data: livros,
                pagination: {
                    page: options.page,
                    size: options.size,
                    total: livros.length
                }
            });
        } catch (error) {
            res.status(500).json({
                erro: error.message,
                codigo: 500,
                timestamp: new Date().toISOString(),
                caminho: req.path
            });
        }
    }

    async obterLivro(req, res) {
        try {
            const { id } = req.params;
            const livro = await this.livroService.obterLivro(id);
            
            res.status(200).json(livro);
        } catch (error) {
            if (error.message.includes('n√£o encontrado')) {
                res.status(404).json({
                    erro: error.message,
                    codigo: 404,
                    timestamp: new Date().toISOString(),
                    caminho: req.path
                });
            } else {
                res.status(500).json({
                    erro: error.message,
                    codigo: 500,
                    timestamp: new Date().toISOString(),
                    caminho: req.path
                });
            }
        }
    }

    async criarLivro(req, res) {
        try {
            const livro = await this.livroService.criarLivro(req.body);
            
            res.status(201).json(livro);
        } catch (error) {
            res.status(400).json({
                erro: error.message,
                codigo: 400,
                timestamp: new Date().toISOString(),
                caminho: req.path
            });
        }
    }

    async atualizarLivro(req, res) {
        try {
            const { id } = req.params;
            const livro = await this.livroService.atualizarLivro(id, req.body);
            
            res.status(200).json(livro);
        } catch (error) {
            if (error.message.includes('n√£o encontrado')) {
                res.status(404).json({
                    erro: error.message,
                    codigo: 404,
                    timestamp: new Date().toISOString(),
                    caminho: req.path
                });
            } else {
                res.status(400).json({
                    erro: error.message,
                    codigo: 400,
                    timestamp: new Date().toISOString(),
                    caminho: req.path
                });
            }
        }
    }

    async removerLivro(req, res) {
        try {
            const { id } = req.params;
            const resultado = await this.livroService.removerLivro(id);
            
            res.status(200).json(resultado);
        } catch (error) {
            if (error.message.includes('n√£o encontrado')) {
                res.status(404).json({
                    erro: error.message,
                    codigo: 404,
                    timestamp: new Date().toISOString(),
                    caminho: req.path
                });
            } else {
                res.status(500).json({
                    erro: error.message,
                    codigo: 500,
                    timestamp: new Date().toISOString(),
                    caminho: req.path
                });
            }
        }
    }
}

module.exports = LivroController;
```

---

### **6. Rotas**

#### **`src/routes/livros.js`**
```javascript
const express = require('express');
const LivroController = require('../controllers/LivroController');

const router = express.Router();
const livroController = new LivroController();

// GET /livros - Listar todos os livros
router.get('/', (req, res) => livroController.listarLivros(req, res));

// GET /livros/:id - Obter um livro espec√≠fico
router.get('/:id', (req, res) => livroController.obterLivro(req, res));

// POST /livros - Criar um novo livro
router.post('/', (req, res) => livroController.criarLivro(req, res));

// PUT /livros/:id - Atualizar um livro
router.put('/:id', (req, res) => livroController.atualizarLivro(req, res));

// DELETE /livros/:id - Remover um livro
router.delete('/:id', (req, res) => livroController.removerLivro(req, res));

module.exports = router;
```

---

### **7. Aplica√ß√£o Principal**

#### **`src/app.js`**
```javascript
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');

// Importar rotas
const livrosRoutes = require('./routes/livros');
const autoresRoutes = require('./routes/autores');
const usuariosRoutes = require('./routes/usuarios');
const emprestimosRoutes = require('./routes/emprestimos');

// Middleware de tratamento de erros
const errorHandler = require('./middleware/errorHandler');

const app = express();
const PORT = process.env.PORT || 3000;

// Middlewares de seguran√ßa e logging
app.use(helmet());
app.use(cors());
app.use(morgan('combined'));

// Middleware para parsing JSON
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Rotas
app.use('/livros', livrosRoutes);
app.use('/autores', autoresRoutes);
app.use('/usuarios', usuariosRoutes);
app.use('/emprestimos', emprestimosRoutes);

// Rota raiz
app.get('/', (req, res) => {
    res.json({
        message: 'API de Biblioteca - Sistema REST',
        version: '1.0.0',
        endpoints: {
            livros: '/livros',
            autores: '/autores',
            usuarios: '/usuarios',
            emprestimos: '/emprestimos'
        }
    });
});

// Middleware de tratamento de erros
app.use(errorHandler);

// Rota para recursos n√£o encontrados
app.use('*', (req, res) => {
    res.status(404).json({
        erro: 'Recurso n√£o encontrado',
        codigo: 404,
        timestamp: new Date().toISOString(),
        caminho: req.originalUrl
    });
});

app.listen(PORT, () => {
    console.log(`üöÄ Servidor rodando na porta ${PORT}`);
    console.log(`üìö API de Biblioteca dispon√≠vel em http://localhost:${PORT}`);
});

module.exports = app;
```

---

### **8. Middleware de Tratamento de Erros**

#### **`src/middleware/errorHandler.js`**
```javascript
const errorHandler = (err, req, res, next) => {
    console.error('Erro:', err);

    // Erro de valida√ß√£o
    if (err.name === 'ValidationError') {
        return res.status(400).json({
            erro: 'Dados inv√°lidos',
            detalhes: err.message,
            codigo: 400,
            timestamp: new Date().toISOString(),
            caminho: req.path
        });
    }

    // Erro de sintaxe JSON
    if (err instanceof SyntaxError && err.status === 400 && 'body' in err) {
        return res.status(400).json({
            erro: 'JSON inv√°lido',
            codigo: 400,
            timestamp: new Date().toISOString(),
            caminho: req.path
        });
    }

    // Erro gen√©rico
    res.status(500).json({
        erro: 'Erro interno do servidor',
        codigo: 500,
        timestamp: new Date().toISOString(),
        caminho: req.path
    });
};

module.exports = errorHandler;
```

---

## üöÄ Como Executar

1. **Instalar depend√™ncias:**
```bash
npm install
```

2. **Executar em desenvolvimento:**
```bash
npm run dev
```

3. **Executar testes:**
```bash
npm test
```

---

## ÔøΩÔøΩ Pr√≥ximos Passos

1. **Implementar** os repositories e services para Usu√°rios e Empr√©stimos
2. **Criar** os controllers e rotas correspondentes
3. **Adicionar** valida√ß√µes mais robustas
4. **Implementar** testes unit√°rios e de integra√ß√£o
5. **Adicionar** documenta√ß√£o com Swagger/OpenAPI

**Quer que eu implemente alguma parte espec√≠fica ou ajude com os pr√≥ximos passos?**

```plaintext
biblioteca-api/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ controllers/          # Controladores REST
‚îÇ   ‚îú‚îÄ‚îÄ services/            # L√≥gica de neg√≥cio
‚îÇ   ‚îú‚îÄ‚îÄ repositories/        # Acesso a dados
‚îÇ   ‚îú‚îÄ‚îÄ models/              # Modelos de dados
‚îÇ   ‚îú‚îÄ‚îÄ routes/              # Defini√ß√£o de rotas
‚îÇ   ‚îú‚îÄ‚îÄ middleware/          # Middlewares customizados
‚îÇ   ‚îú‚îÄ‚îÄ utils/               # Utilit√°rios e helpers
‚îÇ   ‚îú‚îÄ‚îÄ config/              # Configura√ß√µes
‚îÇ   ‚îî‚îÄ‚îÄ app.js               # Aplica√ß√£o principal
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ unit/
‚îÇ   ‚îú‚îÄ‚îÄ integration/
‚îÇ   ‚îî‚îÄ‚îÄ fixtures/
‚îú‚îÄ‚îÄ docs/
‚îú‚îÄ‚îÄ package.json
‚îî‚îÄ‚îÄ README.md
```

```json
{
  "name": "biblioteca-api",
  "version": "1.0.0",
  "description": "Sistema de Biblioteca REST API",
  "main": "src/app.js",
  "scripts": {
    "start": "node src/app.js",
    "dev": "nodemon src/app.js",
    "test": "jest",
    "test:watch": "jest --watch"
  },
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "helmet": "^7.0.0",
    "morgan": "^1.10.0",
    "sqlite3": "^5.1.6",
    "uuid": "^9.0.0"
  },
  "devDependencies": {
    "jest": "^29.5.0",
    "supertest": "^6.3.3",
    "nodemon": "^3.0.1"
  }
}
```

```javascript
const sqlite3 = require('sqlite3').verbose();
const path = require('path');

class Database {
    constructor() {
        this.db = new sqlite3.Database(path.join(__dirname, '../../data/biblioteca.db'));
        this.init();
    }

    init() {
        this.db.serialize(() => {
            // Tabela de Autores
            this.db.run(`
                CREATE TABLE IF NOT EXISTS autores (
                    id TEXT PRIMARY KEY,
                    nome TEXT NOT NULL,
                    biografia TEXT,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            `);

            // Tabela de Livros
            this.db.run(`
                CREATE TABLE IF NOT EXISTS livros (
                    id TEXT PRIMARY KEY,
                    titulo TEXT NOT NULL,
                    isbn TEXT UNIQUE,
                    ano_publicacao INTEGER,
                    disponivel BOOLEAN DEFAULT true,
                    autor_id TEXT,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (autor_id) REFERENCES autores (id)
                )
            `);

            // Tabela de Usu√°rios
            this.db.run(`
                CREATE TABLE IF NOT EXISTS usuarios (
                    id TEXT PRIMARY KEY,
                    nome TEXT NOT NULL,
                    email TEXT UNIQUE,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            `);

            // Tabela de Empr√©stimos
            this.db.run(`
                CREATE TABLE IF NOT EXISTS emprestimos (
                    id TEXT PRIMARY KEY,
                    livro_id TEXT NOT NULL,
                    usuario_id TEXT NOT NULL,
                    data_emprestimo DATETIME DEFAULT CURRENT_TIMESTAMP,
                    data_devolucao DATETIME,
                    devolvido BOOLEAN DEFAULT false,
                    FOREIGN KEY (livro_id) REFERENCES livros (id),
                    FOREIGN KEY (usuario_id) REFERENCES usuarios (id)
                )
            `);
        });
    }

    getConnection() {
        return this.db;
    }
}

module.exports = new Database();
```

```javascript
class Livro {
    constructor(id, titulo, isbn, anoPublicacao, disponivel, autorId, createdAt) {
        this.id = id;
        this.titulo = titulo;
        this.isbn = isbn;
        this.ano_publicacao = anoPublicacao;
        this.disponivel = disponivel;
        this.autor_id = autorId;
        this.created_at = createdAt;
    }

    toJSON() {
        return {
            id: this.id,
            titulo: this.titulo,
            isbn: this.isbn,
            ano_publicacao: this.ano_publicacao,
            disponivel: this.disponivel,
            autor_id: this.autor_id,
            created_at: this.created_at
        };
    }

    static fromRow(row) {
        return new Livro(
            row.id,
            row.titulo,
            row.isbn,
            row.ano_publicacao,
            row.disponivel === 1,
            row.autor_id,
            row.created_at
        );
    }
}

module.exports = Livro;
```

```javascript
class Autor {
    constructor(id, nome, biografia, createdAt) {
        this.id = id;
        this.nome = nome;
        this.biografia = biografia;
        this.created_at = createdAt;
    }

    toJSON() {
        return {
            id: this.id,
            nome: this.nome,
            biografia: this.biografia,
            created_at: this.created_at
        };
    }

    static fromRow(row) {
        return new Autor(
            row.id,
            row.nome,
            row.biografia,
            row.created_at
        );
    }
}

module.exports = Autor;
```

```javascript
const { v4: uuidv4 } = require('uuid');
const database = require('../config/database');
const Livro = require('../models/Livro');

class LivroRepository {
    constructor() {
        this.db = database.getConnection();
    }

    async findAll(options = {}) {
        return new Promise((resolve, reject) => {
            let query = `
                SELECT l.*, a.nome as autor_nome 
                FROM livros l 
                LEFT JOIN autores a ON l.autor_id = a.id
                WHERE 1=1
            `;
            const params = [];

            // Filtros
            if (options.autor) {
                query += ` AND a.nome LIKE ?`;
                params.push(`%${options.autor}%`);
            }

            if (options.disponivel !== undefined) {
                query += ` AND l.disponivel = ?`;
                params.push(options.disponivel ? 1 : 0);
            }

            // Ordena√ß√£o
            if (options.sort) {
                query += ` ORDER BY l.${options.sort} ${options.order || 'ASC'}`;
            }

            // Pagina√ß√£o
            if (options.page && options.size) {
                const offset = (options.page - 1) * options.size;
                query += ` LIMIT ? OFFSET ?`;
                params.push(parseInt(options.size), offset);
            }

            this.db.all(query, params, (err, rows) => {
                if (err) reject(err);
                else resolve(rows.map(row => ({
                    ...Livro.fromRow(row).toJSON(),
                    autor: row.autor_nome ? { id: row.autor_id, nome: row.autor_nome } : null
                })));
            });
        });
    }

    async findById(id) {
        return new Promise((resolve, reject) => {
            const query = `
                SELECT l.*, a.nome as autor_nome 
                FROM livros l 
                LEFT JOIN autores a ON l.autor_id = a.id 
                WHERE l.id = ?
            `;
            
            this.db.get(query, [id], (err, row) => {
                if (err) reject(err);
                else if (!row) resolve(null);
                else resolve({
                    ...Livro.fromRow(row).toJSON(),
                    autor: row.autor_nome ? { id: row.autor_id, nome: row.autor_nome } : null
                });
            });
        });
    }

    async create(livroData) {
        return new Promise((resolve, reject) => {
            const id = uuidv4();
            const query = `
                INSERT INTO livros (id, titulo, isbn, ano_publicacao, disponivel, autor_id)
                VALUES (?, ?, ?, ?, ?, ?)
            `;
            
            this.db.run(query, [
                id,
                livroData.titulo,
                livroData.isbn,
                livroData.ano_publicacao,
                livroData.disponivel !== false,
                livroData.autor_id
            ], function(err) {
                if (err) reject(err);
                else resolve({ id, ...livroData });
            });
        });
    }

    async update(id, livroData) {
        return new Promise((resolve, reject) => {
            const query = `
                UPDATE livros 
                SET titulo = ?, isbn = ?, ano_publicacao = ?, disponivel = ?, autor_id = ?
                WHERE id = ?
            `;
            
            this.db.run(query, [
                livroData.titulo,
                livroData.isbn,
                livroData.ano_publicacao,
                livroData.disponivel !== false,
                livroData.autor_id,
                id
            ], function(err) {
                if (err) reject(err);
                else resolve({ id, ...livroData });
            });
        });
    }

    async delete(id) {
        return new Promise((resolve, reject) => {
            this.db.run('DELETE FROM livros WHERE id = ?', [id], function(err) {
                if (err) reject(err);
                else resolve(this.changes > 0);
            });
        });
    }

    async updateDisponibilidade(id, disponivel) {
        return new Promise((resolve, reject) => {
            this.db.run(
                'UPDATE livros SET disponivel = ? WHERE id = ?',
                [disponivel ? 1 : 0, id],
                function(err) {
                    if (err) reject(err);
                    else resolve(this.changes > 0);
                }
            );
        });
    }
}

module.exports = LivroRepository;
```

```javascript
const { v4: uuidv4 } = require('uuid');
const database = require('../config/database');
const Autor = require('../models/Autor');

class AutorRepository {
    constructor() {
        this.db = database.getConnection();
    }

    async findAll() {
        return new Promise((resolve, reject) => {
            this.db.all('SELECT * FROM autores ORDER BY nome', (err, rows) => {
                if (err) reject(err);
                else resolve(rows.map(row => Autor.fromRow(row).toJSON()));
            });
        });
    }

    async findById(id) {
        return new Promise((resolve, reject) => {
            this.db.get('SELECT * FROM autores WHERE id = ?', [id], (err, row) => {
                if (err) reject(err);
                else if (!row) resolve(null);
                else resolve(Autor.fromRow(row).toJSON());
            });
        });
    }

    async create(autorData) {
        return new Promise((resolve, reject) => {
            const id = uuidv4();
            const query = 'INSERT INTO autores (id, nome, biografia) VALUES (?, ?, ?)';
            
            this.db.run(query, [id, autorData.nome, autorData.biografia], function(err) {
                if (err) reject(err);
                else resolve({ id, ...autorData });
            });
        });
    }

    async update(id, autorData) {
        return new Promise((resolve, reject) => {
            const query = 'UPDATE autores SET nome = ?, biografia = ? WHERE id = ?';
            
            this.db.run(query, [autorData.nome, autorData.biografia, id], function(err) {
                if (err) reject(err);
                else resolve({ id, ...autorData });
            });
        });
    }

    async delete(id) {
        return new Promise((resolve, reject) => {
            this.db.run('DELETE FROM autores WHERE id = ?', [id], function(err) {
                if (err) reject(err);
                else resolve(this.changes > 0);
            });
        });
    }
}

module.exports = AutorRepository;
```

```javascript
const LivroRepository = require('../repositories/LivroRepository');

class LivroService {
    constructor() {
        this.livroRepository = new LivroRepository();
    }

    async listarLivros(options = {}) {
        try {
            const livros = await this.livroRepository.findAll(options);
            return this.adicionarLinksHATEOAS(livros);
        } catch (error) {
            throw new Error(`Erro ao listar livros: ${error.message}`);
        }
    }

    async obterLivro(id) {
        try {
            const livro = await this.livroRepository.findById(id);
            if (!livro) {
                throw new Error('Livro n√£o encontrado');
            }
            return this.adicionarLinksHATEOAS([livro])[0];
        } catch (error) {
            throw new Error(`Erro ao obter livro: ${error.message}`);
        }
    }

    async criarLivro(livroData) {
        try {
            this.validarLivro(livroData);
            const livro = await this.livroRepository.create(livroData);
            return this.adicionarLinksHATEOAS([livro])[0];
        } catch (error) {
            throw new Error(`Erro ao criar livro: ${error.message}`);
        }
    }

    async atualizarLivro(id, livroData) {
        try {
            this.validarLivro(livroData);
            const livroExistente = await this.livroRepository.findById(id);
            if (!livroExistente) {
                throw new Error('Livro n√£o encontrado');
            }
            
            const livro = await this.livroRepository.update(id, livroData);
            return this.adicionarLinksHATEOAS([livro])[0];
        } catch (error) {
            throw new Error(`Erro ao atualizar livro: ${error.message}`);
        }
    }

    async removerLivro(id) {
        try {
            const livroExistente = await this.livroRepository.findById(id);
            if (!livroExistente) {
                throw new Error('Livro n√£o encontrado');
            }
            
            const removido = await this.livroRepository.delete(id);
            if (!removido) {
                throw new Error('Erro ao remover livro');
            }
            return { message: 'Livro removido com sucesso' };
        } catch (error) {
            throw new Error(`Erro ao remover livro: ${error.message}`);
        }
    }

    validarLivro(livroData) {
        if (!livroData.titulo || livroData.titulo.trim().length === 0) {
            throw new Error('T√≠tulo √© obrigat√≥rio');
        }
        
        if (livroData.isbn && !this.validarISBN(livroData.isbn)) {
            throw new Error('ISBN inv√°lido');
        }
        
        if (livroData.ano_publicacao && (livroData.ano_publicacao < 1000 || livroData.ano_publicacao > new Date().getFullYear())) {
            throw new Error('Ano de publica√ß√£o inv√°lido');
        }
    }

    validarISBN(isbn) {
        // Valida√ß√£o b√°sica de ISBN
        const isbnRegex = /^(?:\d{10}|\d{13})$/;
        return isbnRegex.test(isbn.replace(/[-\s]/g, ''));
    }

    adicionarLinksHATEOAS(livros) {
        return livros.map(livro => {
            const links = [
                { rel: 'self', href: `/livros/${livro.id}`, method: 'GET' },
                { rel: 'update', href: `/livros/${livro.id}`, method: 'PUT' },
                { rel: 'delete', href: `/livros/${livro.id}`, method: 'DELETE' }
            ];

            // Links contextuais baseados no estado
            if (livro.disponivel) {
                links.push({ rel: 'emprestar', href: '/emprestimos', method: 'POST' });
            } else {
                links.push({ rel: 'devolver', href: `/emprestimos/${livro.id}/devolucao`, method: 'PUT' });
            }

            return {
                ...livro,
                _links: links
            };
        });
    }
}

module.exports = LivroService;
```

```javascript
const AutorRepository = require('../repositories/AutorRepository');

class AutorService {
    constructor() {
        this.autorRepository = new AutorRepository();
    }

    async listarAutores() {
        try {
            const autores = await this.autorRepository.findAll();
            return this.adicionarLinksHATEOAS(autores);
        } catch (error) {
            throw new Error(`Erro ao listar autores: ${error.message}`);
        }
    }

    async obterAutor(id) {
        try {
            const autor = await this.autorRepository.findById(id);
            if (!autor) {
                throw new Error('Autor n√£o encontrado');
            }
            return this.adicionarLinksHATEOAS([autor])[0];
        } catch (error) {
            throw new Error(`Erro ao obter autor: ${error.message}`);
        }
    }

    async criarAutor(autorData) {
        try {
            this.validarAutor(autorData);
            const autor = await this.autorRepository.create(autorData);
            return this.adicionarLinksHATEOAS([autor])[0];
        } catch (error) {
            throw new Error(`Erro ao criar autor: ${error.message}`);
        }
    }

    async atualizarAutor(id, autorData) {
        try {
            this.validarAutor(autorData);
            const autorExistente = await this.autorRepository.findById(id);
            if (!autorExistente) {
                throw new Error('Autor n√£o encontrado');
            }
            
            const autor = await this.autorRepository.update(id, autorData);
            return this.adicionarLinksHATEOAS([autor])[0];
        } catch (error) {
            throw new Error(`Erro ao atualizar autor: ${error.message}`);
        }
    }

    async removerAutor(id) {
        try {
            const autorExistente = await this.autorRepository.findById(id);
            if (!autorExistente) {
                throw new Error('Autor n√£o encontrado');
            }
            
            const removido = await this.autorRepository.delete(id);
            if (!removido) {
                throw new Error('Erro ao remover autor');
            }
            return { message: 'Autor removido com sucesso' };
        } catch (error) {
            throw new Error(`Erro ao remover autor: ${error.message}`);
        }
    }

    validarAutor(autorData) {
        if (!autorData.nome || autorData.nome.trim().length === 0) {
            throw new Error('Nome √© obrigat√≥rio');
        }
        
        if (autorData.nome.trim().length < 2) {
            throw new Error('Nome deve ter pelo menos 2 caracteres');
        }
    }

    adicionarLinksHATEOAS(autores) {
        return autores.map(autor => ({
            ...autor,
            _links: [
                { rel: 'self', href: `/autores/${autor.id}`, method: 'GET' },
                { rel: 'update', href: `/autores/${autor.id}`, method: 'PUT' },
                { rel: 'delete', href: `/autores/${autor.id}`, method: 'DELETE' },
                { rel: 'livros', href: `/livros?autor_id=${autor.id}`, method: 'GET' }
            ]
        }));
    }
}

module.exports = AutorService;
```

```javascript
const LivroService = require('../services/LivroService');

class LivroController {
    constructor() {
        this.livroService = new LivroService();
    }

    async listarLivros(req, res) {
        try {
            const options = {
                autor: req.query.autor,
                disponivel: req.query.disponivel === 'true',
                sort: req.query.sort,
                order: req.query.order,
                page: parseInt(req.query.page) || 1,
                size: parseInt(req.query.size) || 10
            };

            const livros = await this.livroService.listarLivros(options);
            
            res.status(200).json({
                data: livros,
                pagination: {
                    page: options.page,
                    size: options.size,
                    total: livros.length
                }
            });
        } catch (error) {
            res.status(500).json({
                erro: error.message,
                codigo: 500,
                timestamp: new Date().toISOString(),
                caminho: req.path
            });
        }
    }

    async obterLivro(req, res) {
        try {
            const { id } = req.params;
            const livro = await this.livroService.obterLivro(id);
            
            res.status(200).json(livro);
        } catch (error) {
            if (error.message.includes('n√£o encontrado')) {
                res.status(404).json({
                    erro: error.message,
                    codigo: 404,
                    timestamp: new Date().toISOString(),
                    caminho: req.path
                });
            } else {
                res.status(500).json({
                    erro: error.message,
                    codigo: 500,
                    timestamp: new Date().toISOString(),
                    caminho: req.path
                });
            }
        }
    }

    async criarLivro(req, res) {
        try {
            const livro = await this.livroService.criarLivro(req.body);
            
            res.status(201).json(livro);
        } catch (error) {
            res.status(400).json({
                erro: error.message,
                codigo: 400,
                timestamp: new Date().toISOString(),
                caminho: req.path
            });
        }
    }

    async atualizarLivro(req, res) {
        try {
            const { id } = req.params;
            const livro = await this.livroService.atualizarLivro(id, req.body);
            
            res.status(200).json(livro);
        } catch (error) {
            if (error.message.includes('n√£o encontrado')) {
                res.status(404).json({
                    erro: error.message,
                    codigo: 404,
                    timestamp: new Date().toISOString(),
                    caminho: req.path
                });
            } else {
                res.status(400).json({
                    erro: error.message,
                    codigo: 400,
                    timestamp: new Date().toISOString(),
                    caminho: req.path
                });
            }
        }
    }

    async removerLivro(req, res) {
        try {
            const { id } = req.params;
            const resultado = await this.livroService.removerLivro(id);
            
            res.status(200).json(resultado);
        } catch (error) {
            if (error.message.includes('n√£o encontrado')) {
                res.status(404).json({
                    erro: error.message,
                    codigo: 404,
                    timestamp: new Date().toISOString(),
                    caminho: req.path
                });
            } else {
                res.status(500).json({
                    erro: error.message,
                    codigo: 500,
                    timestamp: new Date().toISOString(),
                    caminho: req.path
                });
            }
        }
    }
}

module.exports = LivroController;
```

```javascript
const express = require('express');
const LivroController = require('../controllers/LivroController');

const router = express.Router();
const livroController = new LivroController();

// GET /livros - Listar todos os livros
router.get('/', (req, res) => livroController.listarLivros(req, res));

// GET /livros/:id - Obter um livro espec√≠fico
router.get('/:id', (req, res) => livroController.obterLivro(req, res));

// POST /livros - Criar um novo livro
router.post('/', (req, res) => livroController.criarLivro(req, res));

// PUT /livros/:id - Atualizar um livro
router.put('/:id', (req, res) => livroController.atualizarLivro(req, res));

// DELETE /livros/:id - Remover um livro
router.delete('/:id', (req, res) => livroController.removerLivro(req, res));

module.exports = router;
```

```javascript
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');

// Importar rotas
const livrosRoutes = require('./routes/livros');
const autoresRoutes = require('./routes/autores');
const usuariosRoutes = require('./routes/usuarios');
const emprestimosRoutes = require('./routes/emprestimos');

// Middleware de tratamento de erros
const errorHandler = require('./middleware/errorHandler');

const app = express();
const PORT = process.env.PORT || 3000;

// Middlewares de seguran√ßa e logging
app.use(helmet());
app.use(cors());
app.use(morgan('combined'));

// Middleware para parsing JSON
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Rotas
app.use('/livros', livrosRoutes);
app.use('/autores', autoresRoutes);
app.use('/usuarios', usuariosRoutes);
app.use('/emprestimos', emprestimosRoutes);

// Rota raiz
app.get('/', (req, res) => {
    res.json({
        message: 'API de Biblioteca - Sistema REST',
        version: '1.0.0',
        endpoints: {
            livros: '/livros',
            autores: '/autores',
            usuarios: '/usuarios',
            emprestimos: '/emprestimos'
        }
    });
});

// Middleware de tratamento de erros
app.use(errorHandler);

// Rota para recursos n√£o encontrados
app.use('*', (req, res) => {
    res.status(404).json({
        erro: 'Recurso n√£o encontrado',
        codigo: 404,
        timestamp: new Date().toISOString(),
        caminho: req.originalUrl
    });
});

app.listen(PORT, () => {
    console.log(`üöÄ Servidor rodando na porta ${PORT}`);
    console.log(`üìö API de Biblioteca dispon√≠vel em http://localhost:${PORT}`);
});

module.exports = app;
```

```javascript
const errorHandler = (err, req, res, next) => {
    console.error('Erro:', err);

    // Erro de valida√ß√£o
    if (err.name === 'ValidationError') {
        return res.status(400).json({
            erro: 'Dados inv√°lidos',
            detalhes: err.message,
            codigo: 400,
            timestamp: new Date().toISOString(),
            caminho: req.path
        });
    }

    // Erro de sintaxe JSON
    if (err instanceof SyntaxError && err.status === 400 && 'body' in err) {
        return res.status(400).json({
            erro: 'JSON inv√°lido',
            codigo: 400,
            timestamp: new Date().toISOString(),
            caminho: req.path
        });
    }

    // Erro gen√©rico
    res.status(500).json({
        erro: 'Erro interno do servidor',
        codigo: 500,
        timestamp: new Date().toISOString(),
        caminho: req.path
    });
};

module.exports = errorHandler;
```

```shellscript
npm install
```

```shellscript
npm run dev
```

```shellscript
npm test
```

